<!DOCTYPE html>
<html lang="ru"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Итераторы</title>
    <meta charset="utf-8">
    <!-- <link rel="stylesheet" href="https://my.devclub.com.ua/static/dragonscale.css?43"> -->
    <link rel="stylesheet" href="Iterators_files/style.htm">
    <style>
        body {
            color: #0F0F0F;
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
            font-size: 13px;
            line-height: 18px;
            max-width: 1024px;
        }
        .notabene {
            font-style: italic;
        }
        code, pre {
            display: block;
            background-color: #CCC;
            border-radius: 5px;
            color: #0F0F0F;
            font-family: Menlo, Monaco, "Courier New", monospace;
            padding: 5px 10px;
            margin-bottom: 9px;
            white-space: pre-wrap;
        }
    </style>
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body>
    <section>
        <h1>Итераторы</h1>
        <p>Даже в повседневной жизни у нас часто возникает задача 
обработать каждый элемент из некоего набора. К примеру, вымыть каждую 
тарелку из горы грязной посуды, прочитать каждую страницу в книге и тому
 подобное.</p>
        <p>Ну а в програмном коде такие ситуации возникают постоянно. 
Перебрать элементы массива, перебрать члены математической 
последовательности, перебрать строки, числа, символы в файле - словом, 
много чего можно перебрать. В связи с этим у нас возникают определенные 
трудности, связанные с принципиально различным получением следующего 
элемента в каждом из приведенных примеров.</p>
        <p>Инструмент, предназначенный для перебора элементов 
последовательности, который позволяет абстрагироваться от получения 
элементов конкретной последовательности, называется <em>итератором</em> 
либо курсором. Общий интерфейс позволяет перестраивать работу программы с
 различными наборами данных, не изменяя код самой программы.</p>
        <p class="notabene">Поскольку смысл итератора в том, чтобы перебрать <strong>все</strong>
 элементы из набора, последоватлеьность для итерации не может быть 
бесконечной. В случае, если последовательность бесконечна по своей 
природе (ряд Фибоначчи, например) вводится искуственное ограничение 
количества элементов.</p>
        <p>Различают одно- и двунаправленные итераторы. Отличие 
двунаправленного итератора в том, что он позволяет переместиться как 
последующему, так и к предыдущему элементу последовательности, в то 
время как однонаправленный - только к последующему. Не для любой 
последовательности возможен двунаправленный итератор.</p>
        <div>В высокоуровневых языках программирования итератор 
реализуется как класс, обладающий определенным набором методов. Как 
минимум, необходимы следующие возможности:
            <ul>
                <li>конструктор, в котором задаются параметры последовательности;
                    <div class="notabene">Для итерации по массиву нам, 
разумеется, понадобится принять в конструктор массив, а для полноты 
картины еще и его размер. Для итерации по файлу нам понадобится либо 
открытый файловый объект, либо же имя файла. Для арифметической 
прогрессии понадобятся значения ее первого члена, шаг прогрессии и 
желаемое количество членов либо индексы первого и последнего элементов;</div></li>
                <li>переход к следующему элементу;</li>
                <li>получение текущего значения;</li>
                <li>индикатор окончания последовательности.</li>
            </ul>
        Дополнительные возможности:
        <ul>
            <li>переход к предыдущему элементу (только для двунаправленного итератора);</li>
            <li>сброс итератора в начальное положение;</li>
            <li>переход к определенному индексу в последовательности (только если такой переход возможен и легко осуществим);</li>
            <li>получение элемента по определенному индексу (только если
 это возможно и легко осуществимо. Отличие от предыдущего пункта в том, 
что получение элемента по индексу не меняет текущее состояние итератора)</li>
        </ul>
        </div>
        <h3>Пример использования:</h3>
        <code>#include &lt;iostream&gt;
#include "NaturalIterator.cpp"

using namespace std;

int main() {
    NaturalIterator seq(10);

    for ( ; !seq.over(); seq.next() ) {
        cout &lt;&lt; seq.value() &lt;&lt; endl;
    }

    return 0;
}</code>
        <h3>Пример использования c перегруженными операторами:</h3>
<code>#include &lt;iostream&gt;
#include "NaturalIterator.cpp"

using namespace std;

int main() {
    NaturalIterator seq(10);

    for ( ; !seq.over(); seq++ ) {
        cout &lt;&lt; *seq &lt;&lt; endl;
    }

    return 0;
}</code>
        <h3>Реализация класса:</h3>
<code>class NaturalIterator {
    private:
        int limit;
        int current;

    public:
        NaturalIterator(int limit) : limit(limit), current(1) {}

        void next() {
            if ( over() ) { // проверка чтобы не выскочить за границу
                return;
            }
            current += 1;
        }

        void operator++() { next(); }

        void operator++(int) { operator++(); }

        bool over() { return current &gt; limit; }

        int value() { return current; }

        int operator*() { return value(); }
};</code>
        <h3>Перестроим программу для работы с массивом:</h3>
<code>#include &lt;iostream&gt;
#include "ArrayIterator.cpp"

using namespace std;

int main() {
    int array[10] = { 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 };
    ArrayIterator seq(array, 10);

    for ( ; !seq.over(); seq++ ) {
        cout &lt;&lt; *seq &lt;&lt; endl;
    }

    return 0;
}</code>
    <div class="notabene">Обратите внимание, что основной код программы остался без изменений. Для объёмного приложения это существенно.</div>
    <p>Осталось только написать класс для работы с массивом.</p>
    </section>
</body></html>